{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.encrypt = exports.verifyHmac = exports.generateKey = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst isoCrypto = tslib_1.__importStar(require(\"@pedrouid/iso-crypto\"));\n\nconst encUtils = tslib_1.__importStar(require(\"enc-utils\"));\n\nconst utils_1 = require(\"@walletconnect/utils\");\n\nfunction generateKey(length) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const _length = (length || 256) / 8;\n\n    const bytes = isoCrypto.randomBytes(_length);\n    const result = utils_1.convertBufferToArrayBuffer(encUtils.arrayToBuffer(bytes));\n    return result;\n  });\n}\n\nexports.generateKey = generateKey;\n\nfunction verifyHmac(payload, key) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const cipherText = encUtils.hexToArray(payload.data);\n    const iv = encUtils.hexToArray(payload.iv);\n    const hmac = encUtils.hexToArray(payload.hmac);\n    const hmacHex = encUtils.arrayToHex(hmac, false);\n    const unsigned = encUtils.concatArrays(cipherText, iv);\n    const chmac = yield isoCrypto.hmacSha256Sign(key, unsigned);\n    const chmacHex = encUtils.arrayToHex(chmac, false);\n\n    if (encUtils.removeHexPrefix(hmacHex) === encUtils.removeHexPrefix(chmacHex)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nexports.verifyHmac = verifyHmac;\n\nfunction encrypt(data, key, providedIv) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const _key = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(key));\n\n    const ivArrayBuffer = providedIv || (yield generateKey(128));\n    const iv = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(ivArrayBuffer));\n    const ivHex = encUtils.arrayToHex(iv, false);\n    const contentString = JSON.stringify(data);\n    const content = encUtils.utf8ToArray(contentString);\n    const cipherText = yield isoCrypto.aesCbcEncrypt(iv, _key, content);\n    const cipherTextHex = encUtils.arrayToHex(cipherText, false);\n    const unsigned = encUtils.concatArrays(cipherText, iv);\n    const hmac = yield isoCrypto.hmacSha256Sign(_key, unsigned);\n    const hmacHex = encUtils.arrayToHex(hmac, false);\n    return {\n      data: cipherTextHex,\n      hmac: hmacHex,\n      iv: ivHex\n    };\n  });\n}\n\nexports.encrypt = encrypt;\n\nfunction decrypt(payload, key) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const _key = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(key));\n\n    if (!_key) {\n      throw new Error(\"Missing key: required for decryption\");\n    }\n\n    const verified = yield verifyHmac(payload, _key);\n\n    if (!verified) {\n      return null;\n    }\n\n    const cipherText = encUtils.hexToArray(payload.data);\n    const iv = encUtils.hexToArray(payload.iv);\n    const buffer = yield isoCrypto.aesCbcDecrypt(iv, _key, cipherText);\n    const utf8 = encUtils.arrayToUtf8(buffer);\n    let data;\n\n    try {\n      data = JSON.parse(utf8);\n    } catch (error) {\n      return null;\n    }\n\n    return data;\n  });\n}\n\nexports.decrypt = decrypt;","map":null,"metadata":{},"sourceType":"script"}