{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst client_1 = tslib_1.__importDefault(require(\"@walletconnect/client\"));\n\nconst qrcode_modal_1 = tslib_1.__importDefault(require(\"@walletconnect/qrcode-modal\"));\n\nconst http_connection_1 = tslib_1.__importDefault(require(\"@walletconnect/http-connection\"));\n\nconst utils_1 = require(\"@walletconnect/utils\");\n\nconst ProviderEngine = require(\"web3-provider-engine\");\n\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\n\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\n\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\n\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\n\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\n\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\n\nclass WalletConnectProvider extends ProviderEngine {\n  constructor(opts) {\n    super({\n      pollingInterval: opts.pollingInterval || 8000\n    });\n    this.bridge = \"https://bridge.walletconnect.org\";\n    this.qrcode = true;\n    this.qrcodeModal = qrcode_modal_1.default;\n    this.qrcodeModalOptions = undefined;\n    this.rpc = null;\n    this.infuraId = \"\";\n    this.http = null;\n    this.isConnecting = false;\n    this.connected = false;\n    this.connectCallbacks = [];\n    this.accounts = [];\n    this.chainId = 1;\n    this.networkId = 1;\n    this.rpcUrl = \"\";\n\n    this.enable = () => tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const wc = yield this.getWalletConnector();\n\n      if (wc) {\n        this.start();\n        this.subscribeWalletConnector();\n        return wc.accounts;\n      } else {\n        throw new Error(\"Failed to connect to WalleConnect\");\n      }\n    });\n\n    this.request = payload => tslib_1.__awaiter(this, void 0, void 0, function* () {\n      return this.send(payload);\n    });\n\n    this.send = (payload, callback) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n      if (typeof payload === \"string\") {\n        const method = payload;\n        let params = callback;\n\n        if (method === \"personal_sign\") {\n          params = utils_1.parsePersonalSign(params);\n        }\n\n        return this.sendAsyncPromise(method, params);\n      }\n\n      payload = Object.assign({\n        id: utils_1.payloadId(),\n        jsonrpc: \"2.0\"\n      }, payload);\n\n      if (payload.method === \"personal_sign\") {\n        payload.params = utils_1.parsePersonalSign(payload.params);\n      }\n\n      if (callback) {\n        this.sendAsync(payload, callback);\n        return;\n      }\n\n      return this.sendAsyncPromise(payload.method, payload.params);\n    });\n\n    this.onConnect = callback => {\n      this.connectCallbacks.push(callback);\n    };\n\n    this.triggerConnect = result => {\n      if (this.connectCallbacks && this.connectCallbacks.length) {\n        this.connectCallbacks.forEach(callback => callback(result));\n      }\n    };\n\n    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || \"https://bridge.walletconnect.org\";\n    this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n    this.qrcodeModalOptions = opts.qrcodeModalOptions;\n    this.wc = opts.connector || new client_1.default({\n      bridge: this.bridge,\n      qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n      qrcodeModalOptions: this.qrcodeModalOptions,\n      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta\n    });\n    this.rpc = opts.rpc || null;\n\n    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n      throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n    }\n\n    this.infuraId = opts.infuraId || \"\";\n    this.chainId = typeof opts.chainId !== \"undefined\" ? opts.chainId : 1;\n    this.networkId = this.chainId;\n    this.initialize();\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get connector() {\n    return this.wc;\n  }\n\n  get walletMeta() {\n    return this.wc.peerMeta;\n  }\n\n  disconnect() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      this.close();\n    });\n  }\n\n  close() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const wc = yield this.getWalletConnector({\n        disableSessionCreation: true\n      });\n      yield wc.killSession();\n      yield this.onDisconnect();\n    });\n  }\n\n  handleRequest(payload) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        let response;\n        let result = null;\n        const wc = yield this.getWalletConnector();\n\n        switch (payload.method) {\n          case \"wc_killSession\":\n            yield this.close();\n            result = null;\n            break;\n\n          case \"eth_accounts\":\n            result = wc.accounts;\n            break;\n\n          case \"eth_coinbase\":\n            result = wc.accounts[0];\n            break;\n\n          case \"eth_chainId\":\n            result = wc.chainId;\n            break;\n\n          case \"net_version\":\n            result = wc.networkId || wc.chainId;\n            break;\n\n          case \"eth_uninstallFilter\":\n            this.sendAsync(payload, _ => _);\n            result = true;\n            break;\n\n          default:\n            response = yield this.handleOtherRequests(payload);\n        }\n\n        if (response) {\n          return response;\n        }\n\n        return this.formatResponse(payload, result);\n      } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n      }\n    });\n  }\n\n  handleOtherRequests(payload) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      if (!utils_1.signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n        return this.handleReadRequests(payload);\n      }\n\n      const wc = yield this.getWalletConnector();\n      const result = yield wc.sendCustomRequest(payload);\n      return this.formatResponse(payload, result);\n    });\n  }\n\n  handleReadRequests(payload) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      if (!this.http) {\n        const error = new Error(\"HTTP Connection not available\");\n        this.emit(\"error\", error);\n        throw error;\n      }\n\n      return this.http.send(payload);\n    });\n  }\n\n  formatResponse(payload, result) {\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result: result\n    };\n  }\n\n  getWalletConnector(opts = {}) {\n    const {\n      disableSessionCreation = false\n    } = opts;\n    return new Promise((resolve, reject) => {\n      const wc = this.wc;\n\n      if (this.isConnecting) {\n        this.onConnect(x => resolve(x));\n      } else if (!wc.connected && !disableSessionCreation) {\n        this.isConnecting = true;\n        const sessionRequestOpions = this.chainId ? {\n          chainId: this.chainId\n        } : undefined;\n        wc.on(\"modal_closed\", () => {\n          reject(new Error(\"User closed modal\"));\n        });\n        wc.createSession(sessionRequestOpions).then(() => {\n          wc.on(\"connect\", (error, payload) => {\n            if (error) {\n              this.isConnecting = false;\n              return reject(error);\n            }\n\n            this.isConnecting = false;\n            this.connected = true;\n\n            if (payload) {\n              this.updateState(payload.params[0]);\n            }\n\n            this.emit(\"connect\");\n            this.triggerConnect(wc);\n            resolve(wc);\n          });\n        }).catch(error => {\n          this.isConnecting = false;\n          reject(error);\n        });\n      } else {\n        if (!this.connected) {\n          this.connected = true;\n          this.updateState(wc.session);\n        }\n\n        resolve(wc);\n      }\n    });\n  }\n\n  subscribeWalletConnector() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const wc = yield this.getWalletConnector();\n      wc.on(\"disconnect\", error => {\n        if (error) {\n          this.emit(\"error\", error);\n          return;\n        }\n\n        this.onDisconnect();\n      });\n      wc.on(\"session_update\", (error, payload) => {\n        if (error) {\n          this.emit(\"error\", error);\n          return;\n        }\n\n        this.updateState(payload.params[0]);\n      });\n    });\n  }\n\n  onDisconnect() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      yield this.stop();\n      this.emit(\"close\", 1000, \"Connection closed\");\n      this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n    });\n  }\n\n  updateState(sessionParams) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const {\n        accounts,\n        chainId,\n        networkId,\n        rpcUrl\n      } = sessionParams;\n\n      if (!this.accounts || accounts && this.accounts !== accounts) {\n        this.accounts = accounts;\n        this.emit(\"accountsChanged\", accounts);\n      }\n\n      if (!this.chainId || chainId && this.chainId !== chainId) {\n        this.chainId = chainId;\n        this.emit(\"chainChanged\", chainId);\n      }\n\n      if (!this.networkId || networkId && this.networkId !== networkId) {\n        this.networkId = networkId;\n        this.emit(\"networkChanged\", networkId);\n      }\n\n      this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n    });\n  }\n\n  updateRpcUrl(chainId, rpcUrl = \"\") {\n    const infuraNetworks = {\n      1: \"mainnet\",\n      3: \"ropsten\",\n      4: \"rinkeby\",\n      5: \"goerli\",\n      42: \"kovan\"\n    };\n    const network = infuraNetworks[chainId];\n\n    if (!rpcUrl) {\n      if (this.rpc && this.rpc[chainId]) {\n        rpcUrl = this.rpc[chainId];\n      } else if (network) {\n        rpcUrl = `https://${network}.infura.io/v3/${this.infuraId}`;\n      }\n    }\n\n    if (rpcUrl) {\n      this.rpcUrl = rpcUrl;\n      this.updateHttpConnection();\n    } else {\n      this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n    }\n  }\n\n  updateHttpConnection() {\n    if (this.rpcUrl) {\n      this.http = new http_connection_1.default(this.rpcUrl);\n      this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n      this.http.on(\"error\", error => this.emit(\"error\", error));\n    }\n  }\n\n  sendAsyncPromise(method, params) {\n    return new Promise((resolve, reject) => {\n      this.sendAsync({\n        id: utils_1.payloadId(),\n        jsonrpc: \"2.0\",\n        method,\n        params: params || []\n      }, (error, response) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(response.result);\n      });\n    });\n  }\n\n  initialize() {\n    this.updateRpcUrl(this.chainId);\n    this.addProvider(new FixtureSubprovider({\n      eth_hashrate: \"0x00\",\n      eth_mining: false,\n      eth_syncing: true,\n      net_listening: true,\n      web3_clientVersion: `WalletConnect/v1.x.x/javascript`\n    }));\n    this.addProvider(new CacheSubprovider());\n    this.addProvider(new SubscriptionsSubprovider());\n    this.addProvider(new FilterSubprovider());\n    this.addProvider(new NonceSubprovider());\n    this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n    this.addProvider({\n      handleRequest: (payload, next, end) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const {\n            result\n          } = yield this.handleRequest(payload);\n          end(null, result);\n        } catch (error) {\n          end(error);\n        }\n      }),\n      setEngine: _ => _\n    });\n  }\n\n  configWallet() {\n    return {\n      getAccounts: cb => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const accounts = wc.accounts;\n\n          if (accounts && accounts.length) {\n            cb(null, accounts);\n          } else {\n            cb(new Error(\"Failed to get accounts\"));\n          }\n        } catch (error) {\n          cb(error);\n        }\n      }),\n      processMessage: (msgParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const result = yield wc.signMessage([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }),\n      processPersonalMessage: (msgParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const result = yield wc.signPersonalMessage([msgParams.data, msgParams.from]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }),\n      processSignTransaction: (txParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const result = yield wc.signTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }),\n      processTransaction: (txParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const result = yield wc.sendTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }),\n      processTypedMessage: (msgParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const result = yield wc.signTypedData([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      })\n    };\n  }\n\n}\n\nexports.default = WalletConnectProvider;","map":null,"metadata":{},"sourceType":"script"}