{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseTransactionData = exports.parsePersonalSign = exports.isValidAddress = exports.toChecksumAddress = void 0;\n\nconst js_sha3_1 = require(\"js-sha3\");\n\nconst encoding_1 = require(\"./encoding\");\n\nconst misc_1 = require(\"./misc\");\n\nconst validators_1 = require(\"./validators\");\n\nconst enc_utils_1 = require(\"enc-utils\");\n\nfunction toChecksumAddress(address) {\n  address = enc_utils_1.removeHexPrefix(address.toLowerCase());\n  const hash = enc_utils_1.removeHexPrefix(js_sha3_1.keccak_256(encoding_1.convertUtf8ToBuffer(address)));\n  let checksum = \"\";\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) > 7) {\n      checksum += address[i].toUpperCase();\n    } else {\n      checksum += address[i];\n    }\n  }\n\n  return enc_utils_1.addHexPrefix(checksum);\n}\n\nexports.toChecksumAddress = toChecksumAddress;\n\nconst isValidAddress = address => {\n  if (!address) {\n    return false;\n  } else if (address.toLowerCase().substring(0, 2) !== \"0x\") {\n    return false;\n  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    return false;\n  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {\n    return true;\n  } else {\n    return address === toChecksumAddress(address);\n  }\n};\n\nexports.isValidAddress = isValidAddress;\n\nfunction parsePersonalSign(params) {\n  if (!validators_1.isEmptyArray(params) && !validators_1.isHexString(params[0])) {\n    params[0] = encoding_1.convertUtf8ToHex(params[0]);\n  }\n\n  return params;\n}\n\nexports.parsePersonalSign = parsePersonalSign;\n\nfunction parseTransactionData(txData) {\n  if (typeof txData.from === \"undefined\" || !exports.isValidAddress(txData.from)) {\n    throw new Error(`Transaction object must include a valid 'from' value.`);\n  }\n\n  function parseHexValues(value) {\n    let result = value;\n\n    if (typeof value === \"number\" || typeof value === \"string\" && !validators_1.isEmptyString(value)) {\n      if (!validators_1.isHexString(value)) {\n        result = encoding_1.convertNumberToHex(value);\n      } else if (typeof value === \"string\") {\n        result = misc_1.sanitizeHex(value);\n      }\n    }\n\n    if (typeof result === \"string\") {\n      result = misc_1.removeHexLeadingZeros(result);\n    }\n\n    return result;\n  }\n\n  const txDataRPC = {\n    from: misc_1.sanitizeHex(txData.from),\n    to: typeof txData.to === \"undefined\" ? \"\" : misc_1.sanitizeHex(txData.to),\n    gasPrice: typeof txData.gasPrice === \"undefined\" ? \"\" : parseHexValues(txData.gasPrice),\n    gas: typeof txData.gas === \"undefined\" ? typeof txData.gasLimit === \"undefined\" ? \"\" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),\n    value: typeof txData.value === \"undefined\" ? \"\" : parseHexValues(txData.value),\n    nonce: typeof txData.nonce === \"undefined\" ? \"\" : parseHexValues(txData.nonce),\n    data: typeof txData.data === \"undefined\" ? \"\" : misc_1.sanitizeHex(txData.data) || \"0x\"\n  };\n  const prunable = [\"gasPrice\", \"gas\", \"value\", \"nonce\"];\n  Object.keys(txDataRPC).forEach(key => {\n    if (!txDataRPC[key].trim().length && prunable.includes(key)) {\n      delete txDataRPC[key];\n    }\n  });\n  return txDataRPC;\n}\n\nexports.parseTransactionData = parseTransactionData;","map":null,"metadata":{},"sourceType":"script"}